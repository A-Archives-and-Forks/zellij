// This file contains conversion code between `EventType` and `ProtobufEventType`
// `EventType` - this is the struct used by both Zellij and Rust plugins
// `ProtobufEventType` - this is the struct generated by the `.proto` file and used for serialization
// across the wasm boundary
//
// SDK authors in other languages should generate their own equivalent structures based on the
// `.proto` specification, and then decode the protobuf over the wire into them

pub mod api {
    // this is a compile time asset generated from the `.proto` specification file by Prost to give
    // us the ProtobufEventType structure we are gathered here to avoid
    include!(concat!(env!("OUT_DIR"), "/api.event.rs"));
}

pub use api::{EventType as ProtobufEventType, EventNameList as ProtobufEventNameList};
use crate::data::EventType;

use std::convert::TryFrom;
use std::collections::HashSet;
 
impl TryFrom<ProtobufEventNameList> for HashSet<EventType> {
   type Error = &'static str;
   fn try_from(protobuf_event_name_list: ProtobufEventNameList) -> Result<Self, &'static str> {
       let event_types: Vec<ProtobufEventType> = protobuf_event_name_list.event_types.iter().filter_map(|i| ProtobufEventType::from_i32(*i)).collect();
       let event_types: Vec<EventType> = event_types.iter().filter_map(|e| EventType::try_from(*e).ok()).collect();
       Ok(event_types.into_iter().collect())
   }
}

impl TryFrom<HashSet<EventType>> for ProtobufEventNameList {
   type Error = &'static str;
   fn try_from(event_types: HashSet<EventType>) -> Result<Self, &'static str> {
       // TODO: CONTINUE HERE (07/07) - implement this, then consider refactoring the above and
       // then get subscribe/unsubscribe to use these and see how it goes
       unimplemented!()
   }
}

impl TryFrom<ProtobufEventType> for EventType {
   type Error = &'static str;
   fn try_from(protobuf_event_type: ProtobufEventType) -> Result<Self, &'static str> {
       Ok(match protobuf_event_type {
           // TODO: strum macro?
           ProtobufEventType::ModeUpdate => EventType::ModeUpdate,
           ProtobufEventType::TabUpdate => EventType::TabUpdate,
           ProtobufEventType::PaneUpdate => EventType::PaneUpdate,
           ProtobufEventType::Key => EventType::Key,
           ProtobufEventType::Mouse => EventType::Mouse,
           ProtobufEventType::Timer => EventType::Timer,
           ProtobufEventType::CopyToClipboard => EventType::CopyToClipboard,
           ProtobufEventType::SystemClipboardFailure => EventType::SystemClipboardFailure,
           ProtobufEventType::InputReceived => EventType::InputReceived,
           ProtobufEventType::Visible => EventType::Visible,
           ProtobufEventType::CustomMessage => EventType::CustomMessage,
           ProtobufEventType::FileSystemCreate => EventType::FileSystemCreate,
           ProtobufEventType::FileSystemRead => EventType::FileSystemRead,
           ProtobufEventType::FileSystemUpdate => EventType::FileSystemUpdate,
           ProtobufEventType::FileSystemDelete => EventType::FileSystemDelete,
       })
   }
}

impl TryFrom<EventType> for ProtobufEventType {
   type Error = &'static str;
   fn try_from(event_type: EventType) -> Result<Self, &'static str> {
       Ok(match event_type {
           // TODO: strum macro?
           EventType::ModeUpdate => ProtobufEventType::ModeUpdate,
           EventType::TabUpdate => ProtobufEventType::TabUpdate,
           EventType::PaneUpdate => ProtobufEventType::PaneUpdate,
           EventType::Key => ProtobufEventType::Key,
           EventType::Mouse => ProtobufEventType::Mouse,
           EventType::Timer => ProtobufEventType::Timer,
           EventType::CopyToClipboard => ProtobufEventType::CopyToClipboard,
           EventType::SystemClipboardFailure => ProtobufEventType::SystemClipboardFailure,
           EventType::InputReceived => ProtobufEventType::InputReceived,
           EventType::Visible => ProtobufEventType::Visible,
           EventType::CustomMessage => ProtobufEventType::CustomMessage,
           EventType::FileSystemCreate => ProtobufEventType::FileSystemCreate,
           EventType::FileSystemRead => ProtobufEventType::FileSystemRead,
           EventType::FileSystemUpdate => ProtobufEventType::FileSystemUpdate,
           EventType::FileSystemDelete => ProtobufEventType::FileSystemDelete,
       })
   }
}
 
// impl TryFrom<Key> for ProtobufKey {
//     type Error = &'static str;
//     fn try_from(key: Key) -> Result<Self, &'static str> {
//         match key {
//             Key::PageDown => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::PageDown as i32)),
//                 })
//             },
//             Key::PageUp => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::PageUp as i32)),
//                 })
//             },
//             Key::Left => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::LeftArrow as i32)),
//                 })
//             }
//             Key::Down => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::DownArrow as i32)),
//                 })
//             }
//             Key::Up => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::UpArrow as i32)),
//                 })
//             }
//             Key::Right => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::RightArrow as i32)),
//                 })
//             }
//             Key::Home => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::Home as i32)),
//                 })
//             }
//             Key::End => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::End as i32)),
//                 })
//             }
//             Key::Backspace => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::Backspace as i32)),
//                 })
//             }
//             Key::Delete => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::Delete as i32)),
//                 })
//             }
//             Key::Insert => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::Insert as i32)),
//                 })
//             }
//             Key::F(index) => {
//                 let main_key = match index {
//                     1 => Some(MainKey::Key(NamedKey::F1 as i32)),
//                     2 => Some(MainKey::Key(NamedKey::F2 as i32)),
//                     3 => Some(MainKey::Key(NamedKey::F3 as i32)),
//                     4 => Some(MainKey::Key(NamedKey::F4 as i32)),
//                     5 => Some(MainKey::Key(NamedKey::F5 as i32)),
//                     6 => Some(MainKey::Key(NamedKey::F6 as i32)),
//                     7 => Some(MainKey::Key(NamedKey::F7 as i32)),
//                     8 => Some(MainKey::Key(NamedKey::F8 as i32)),
//                     9 => Some(MainKey::Key(NamedKey::F9 as i32)),
//                     10 => Some(MainKey::Key(NamedKey::F10 as i32)),
//                     11 => Some(MainKey::Key(NamedKey::F11 as i32)),
//                     12 => Some(MainKey::Key(NamedKey::F12 as i32)),
//                     _ => return Err("Invalid key"),
//                 };
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key,
//                 })
//             }
//             Key::Char(character) => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     // 97 is the start of the ASCII alphabet
//                     main_key: Some(MainKey::Char((character as u8 - 97) as i32)),
//                 })
//             }
//             Key::Alt(char_or_arrow) => {
//                 let main_key = match char_or_arrow {
//                     CharOrArrow::Char(character) => MainKey::Char((character as u8 - 97) as i32),
//                     CharOrArrow::Direction(Direction::Left) => MainKey::Key(NamedKey::LeftArrow as i32),
//                     CharOrArrow::Direction(Direction::Right) => MainKey::Key(NamedKey::RightArrow as i32),
//                     CharOrArrow::Direction(Direction::Up) => MainKey::Key(NamedKey::UpArrow as i32),
//                     CharOrArrow::Direction(Direction::Down) => MainKey::Key(NamedKey::DownArrow as i32),
//                 };
//                 Ok(ProtobufKey {
//                     optional_modifier: Some(OptionalModifier::Modifier(KeyModifier::Alt as i32)),
//                     main_key: Some(main_key)
//                 })
//             }
//             Key::Ctrl(character) => {
//                 Ok(ProtobufKey {
//                     optional_modifier: Some(OptionalModifier::Modifier(KeyModifier::Ctrl as i32)),
//                     main_key: Some(MainKey::Char((character as u8 - 97) as i32)),
//                 })
//             }
//             Key::BackTab => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::Tab as i32)),
//                 })
//             }
//             Key::Null => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: None, // TODO: does this break deserialization?
//                 })
//             }
//             Key::Esc => {
//                 Ok(ProtobufKey {
//                     optional_modifier: None,
//                     main_key: Some(MainKey::Key(NamedKey::Esc as i32)),
//                 })
//             }
//         }
//     }
// }
// 
// impl CharOrArrow {
//     pub fn from_main_key(main_key: std::option::Option<MainKey>) -> Result<CharOrArrow, &'static str> {
//         match main_key {
//             Some(MainKey::Char(encoded_key)) => {
//                 Ok(CharOrArrow::Char(char_index_to_char(encoded_key)))
//             },
//             Some(MainKey::Key(key_index)) => {
//                 match NamedKey::from_i32(key_index) {
//                     Some(NamedKey::LeftArrow) => {
//                         Ok(CharOrArrow::Direction(Direction::Left))
//                     },
//                     Some(NamedKey::RightArrow) => {
//                         Ok(CharOrArrow::Direction(Direction::Right))
//                     },
//                     Some(NamedKey::UpArrow) => {
//                         Ok(CharOrArrow::Direction(Direction::Up))
//                     },
//                     Some(NamedKey::DownArrow) => {
//                         Ok(CharOrArrow::Direction(Direction::Down))
//                     },
//                     _ => {
//                         Err("Unsupported key")
//                     }
//                 }
//             }
//             _ => {
//                 return Err("Unsupported key");
//             }
//         }
//     }
// }
// 
// fn parse_optional_modifier(m: &ProtobufKey) -> Option<KeyModifier> {
//     match m.optional_modifier {
//         Some(OptionalModifier::Modifier(modifier)) => KeyModifier::from_i32(modifier),
//         _ => None
//     }
// }
// 
// 
// fn char_index_to_char(char_index: i32) -> char {
//     // 97 is the start of the alphabet in the ASCII table
//     (char_index + 97) as u8 as char
// }
// 
// fn char_from_main_key(main_key: Option<MainKey>) -> Result<char, &'static str> {
//     match main_key {
//         Some(MainKey::Char(encoded_key)) => {
//             return Ok(char_index_to_char(encoded_key));
//         },
//         _ => {
//             return Err("Unsupported key");
//         }
//     }
// }
// 
// fn named_key_to_key(named_key: NamedKey) -> Key {
//     match named_key {
//         NamedKey::PageDown => Key::PageDown,
//         NamedKey::PageUp => Key::PageUp,
//         NamedKey::LeftArrow => Key::Left,
//         NamedKey::DownArrow => Key::Down,
//         NamedKey::UpArrow => Key::Up,
//         NamedKey::RightArrow => Key::Right,
//         NamedKey::Home => Key::Home,
//         NamedKey::End => Key::End,
//         NamedKey::Backspace => Key::Backspace,
//         NamedKey::Delete => Key::Delete,
//         NamedKey::Insert => Key::Insert,
//         NamedKey::F1 => Key::F(1),
//         NamedKey::F2 => Key::F(2),
//         NamedKey::F3 => Key::F(3),
//         NamedKey::F4 => Key::F(4),
//         NamedKey::F5 => Key::F(5),
//         NamedKey::F6 => Key::F(6),
//         NamedKey::F7 => Key::F(7),
//         NamedKey::F8 => Key::F(8),
//         NamedKey::F9 => Key::F(9),
//         NamedKey::F10 => Key::F(10),
//         NamedKey::F11 => Key::F(11),
//         NamedKey::F12 => Key::F(12),
//         NamedKey::Tab => Key::BackTab,
//         NamedKey::Esc => Key::Esc,
//     }
// }
// 
