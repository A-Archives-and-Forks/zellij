// This file contains conversion code between `CommandToRun` and `ProtobufCommand`
// `CommandToRun` - this is the struct used by both Zellij and Rust plugins
// `ProtobufCommand` - this is the struct generated by the `.proto` file and used for serialization
// across the wasm boundary
//
// SDK authors in other languages should generate their own equivalent structures based on the
// `.proto` specification, and then decode the protobuf over the wire into them

pub mod api {
    // this is a compile time asset generated from the `.proto` specification file by Prost to give
    // us the ProtobufCommand structure we are gathered here to avoid
    include!(concat!(env!("OUT_DIR"), "/api.message.rs"));
}

pub use api::{Message as ProtobufMessage, message::OptionalWorkerName};
use crate::data::PluginMessage;

use std::convert::TryFrom;
use std::path::PathBuf;

impl TryFrom<ProtobufMessage> for PluginMessage {
   type Error = &'static str;
   fn try_from(protobuf_message: ProtobufMessage) -> Result<Self, &'static str> {
       let name = protobuf_message.name;
       let payload = protobuf_message.payload;
       let worker_name = protobuf_message.optional_worker_name.map(|n| {
           match n {
               OptionalWorkerName::WorkerName(n) => n
           }
       });
       Ok(PluginMessage {
           name,
           payload,
           worker_name
       })
   }
}

impl TryFrom<PluginMessage> for ProtobufMessage {
   type Error = &'static str;
   fn try_from(plugin_message: PluginMessage) -> Result<Self, &'static str> {
       Ok(ProtobufMessage {
           name: plugin_message.name,
           payload: plugin_message.payload,
           optional_worker_name: plugin_message.worker_name.map(|n| OptionalWorkerName::WorkerName(n))
       })
   }
}
